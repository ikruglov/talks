class: center, middle, inverse

# Optimize Sereal
### September Go meetup, Amsterdam
### Ivan Kruglov

.footnote[
  created with [remark](http://github.com/gnab/remark)
]

---
## Overview

- What Sereal?
- Brief explanation of how Sereal works
- Dig into original Go implementation
- Go though made optimizations

---
## Results

- Sereal::Encoder

```terminal
    sereal-go $ go run psrl.go -folder data/ > data_go.srl
    ...snip...
*    The call took 3.001318514s to run.

    sereal-go $ go run psrl.go -folder data/ -expsize 52428800 > data_go.srl
    ...snip...
*    The call took 708.295852ms to run.
```

.small[
    https://github.com/ikruglov/junk/blob/master/sereal-go/psrl.go
]

---
## Results

- Sereal::Decoder

```terminal
    sereal-go $ go run dec.go -file data_go.srl
    ...snip...
*    Deserialization took 5.542141726s to run.

    sereal-go $ go run dec.go -file data_go.srl
    ...snip...
*    Deserialization took 1.592267889s to run.
```

.small[
    https://github.com/ikruglov/junk/blob/master/sereal-go/dec.go
]

---
## What is Sereal?

- Fast, compact, schema-less, binary serialization and deserialization oriented towards dynamic languages

- Initially written for Perl in perlxs (interface between C and Perl)

- Currently, there are implementations for Perl, Go, Python, objC, Ruby, Java

- https://github.com/Sereal/Sereal

---
## Why Sereal?

- Needed support of:
    - shared references
    - weak references
    - aliases
    - perl regular expresions
    - others

- Wanted to achieve:
    - space efficiencies
    - speed efficiencies
    - https://github.com/Sereal/Sereal/wiki/Sereal-Comparison-Graphs

---
class: center, middle

![encoder-performance](encoder-performance.png)

.small[
    https://github.com/Sereal/Sereal/wiki/Sereal-Comparison-Graphs
]

---
class: center, middle

![encoder-footprint](encoder-footprint.png)

.small[
    https://github.com/Sereal/Sereal/wiki/Sereal-Comparison-Graphs
]

---
class: center, middle

![decoder-performance](decoder-performance.png)

.small[
    https://github.com/Sereal/Sereal/wiki/Sereal-Comparison-Graphs
]

---
## Sereal's specification

.medium[
```
           Tag |  Hex | Follow
---------------+------+------------------------------------------
POS_0          | 0x00 | small positive integer - value in low 4 bits (identity)
POS_1          | 0x01 | 
NEG_16         | 0x10 | small negative integer - value in low 4 bits (k+32)
NEG_15         | 0x11 |
VARINT         | 0x20 | <VARINT> - Varint variable length integer
FLOAT          | 0x22 | <IEEE-FLOAT>
UNDEF          | 0x25 | None - Perl undef var; eg my $var= undef;
BINARY         | 0x26 | <LEN-VARINT> <BYTES> - binary/(latin1) string
REFN           | 0x28 | <ITEM-TAG> - ref to next item
REFP           | 0x29 | <OFFSET-VARINT> - ref to previous item stored at offset
HASH           | 0x2a | <COUNT-VARINT> [<KEY-TAG> <ITEM-TAG> ...] - count followed by key/value pairs
ARRAY          | 0x2b | <COUNT-VARINT> [<ITEM-TAG> ...] - count followed by items
OBJECT         | 0x2c | <STR-TAG> <ITEM-TAG> - class, object-item
ALIAS          | 0x2e | <OFFSET-VARINT> - alias to item defined at offset
COPY           | 0x2f | <OFFSET-VARINT> - copy of item defined at offset
REGEXP         | 0x31 | <PATTERN-STR-TAG> <MODIFIERS-STR-TAG>
FALSE          | 0x3a | false (PL_sv_no)
TRUE           | 0x3b | true  (PL_sv_yes)
ARRAYREF_0     | 0x40 | [<ITEM-TAG> ...] - count of items in low 4 bits (ARRAY must be refcnt=1)
ARRAYREF_1     | 0x41 |
ARRAYREF_2     | 0x42 |
HASHREF_0      | 0x50 | [<KEY-TAG> <ITEM-TAG> ...] - count in low 4 bits, key/value pairs (HASH must be refcnt=1)
HASHREF_1      | 0x51 |
HASHREF_2      | 0x52 |
SHORT_BINARY_0 | 0x60 | <BYTES> - binary/latin1 string, length encoded in low 5 bits of tag
SHORT_BINARY_1 | 0x61 |
SHORT_BINARY_2 | 0x62 |
```
]

# 

.small[
    https://github.com/Sereal/Sereal/blob/master/sereal_spec.pod
]

---
## Example #1

```terminal
perl -MSereal -e 'print encode_sereal("foo")' | hexdump -C
3d f3 72 6c 03 00 63 66 6f 6f
```

--

```terminal
3d f3 72 6c  03        00          63 66 6f 6f

^magic-str   ^version  ^no-options ^SHORT_BINARY_3 + content
\-------------header-------------\ \---------body----------\
```

---
## Example #2

```terminal
perl -MSereal -e 'print encode_sereal({ foo => 10 })' | hexdump -C
3d f3 72 6c 03 00 28 2a 01 63 66 6f 6f 0a
                 /                       \
   --------------                         ------ 
  /                                             \
28    2a     01      63 66 6f 6f                0a

^REFN ^HASH  ^length ^SHORT_BINARY_3 + content  ^POS_10
```

---
## Sereal's specification

.medium[
```
           Tag |  Hex | Follow
---------------+------+------------------------------------------
POS_0          | 0x00 | small positive integer - value in low 4 bits (identity)
POS_1          | 0x01 | 
NEG_16         | 0x10 | small negative integer - value in low 4 bits (k+32)
NEG_15         | 0x11 |
VARINT         | 0x20 | <VARINT> - Varint variable length integer
FLOAT          | 0x22 | <IEEE-FLOAT>
UNDEF          | 0x25 | None - Perl undef var; eg my $var= undef;
BINARY         | 0x26 | <LEN-VARINT> <BYTES> - binary/(latin1) string
REFN           | 0x28 | <ITEM-TAG> - ref to next item
*REFP           | 0x29 | <OFFSET-VARINT> - ref to previous item stored at offset
HASH           | 0x2a | <COUNT-VARINT> [<KEY-TAG> <ITEM-TAG> ...] - count followed by key/value pairs
ARRAY          | 0x2b | <COUNT-VARINT> [<ITEM-TAG> ...] - count followed by items
OBJECT         | 0x2c | <STR-TAG> <ITEM-TAG> - class, object-item
ALIAS          | 0x2e | <OFFSET-VARINT> - alias to item defined at offset
*COPY           | 0x2f | <OFFSET-VARINT> - copy of item defined at offset
REGEXP         | 0x31 | <PATTERN-STR-TAG> <MODIFIERS-STR-TAG>
FALSE          | 0x3a | false (PL_sv_no)
TRUE           | 0x3b | true  (PL_sv_yes)
ARRAYREF_0     | 0x40 | [<ITEM-TAG> ...] - count of items in low 4 bits (ARRAY must be refcnt=1)
ARRAYREF_1     | 0x41 |
ARRAYREF_2     | 0x42 |
HASHREF_0      | 0x50 | [<KEY-TAG> <ITEM-TAG> ...] - count in low 4 bits, key/value pairs (HASH must be refcnt=1)
HASHREF_1      | 0x51 |
HASHREF_2      | 0x52 |
SHORT_BINARY_0 | 0x60 | <BYTES> - binary/latin1 string, length encoded in low 5 bits of tag
SHORT_BINARY_1 | 0x61 |
SHORT_BINARY_2 | 0x62 |
```
]

# 

.small[
    https://github.com/Sereal/Sereal/blob/master/sereal_spec.pod
]

---
## Example #3

.small[
```terminal
perl -MSereal -e 'print encode_sereal(["foobar", "foobar"], { dedupe_strings => 1 })' | hexdump -C
```
]

```terminal
3d f3 72 6c 03 00 42 66 66 6f 6f 62 61 72 2f 02
                 /                            /
  ---------------                            |
 /                                           |
42           66 66 6f 6f 62 61 72       2f 02
^ARRAYREF_2  ^SHORT_BINARY_6 + content  COPY + offset
                                                    |
             ^-----------------here------------------
```

---
## Go implementation

- initially written by Damian Gryski (https://github.com/dgryski)

--

    - this guy is crazy, he has 1-year-long-streak

--

- encoder a.k.a marshaller
```go
func Marshal(v interface{}) ([]byte, error)
```

- decoder a.k.a unmarshaller
```go
func Unmarshal(b []byte, v interface{}) error 
```

---
## Marshaller profile (before)

.small[
```go
(pprof) top30
Total: 3003 samples
     312  10.4%  10.4%      312  10.4% scanblock
     192   6.4%  16.8%      192   6.4% runtime.aeshashbody
     189   6.3%  23.1%      602  20.0% runtime.mallocgc
     178   5.9%  29.0%      190   6.3% runtime.MSpan_Sweep
     148   4.9%  33.9%     2145  71.4% github.com/Sereal/Sereal/Go/sereal.(*Encoder).encode
     108   3.6%  37.5%      109   3.6% settype
     102   3.4%  40.9%      105   3.5% hash_next
      93   3.1%  44.0%       93   3.1% flushptrbuf
      86   2.9%  46.9%      466  15.5% cnew
      78   2.6%  49.5%       94   3.1% itab
      77   2.6%  52.0%      110   3.7% hash_lookup
      76   2.5%  54.6%       76   2.5% runtime.memmove
      74   2.5%  57.0%       74   2.5% markonly
      66   2.2%  59.2%       66   2.2% reflect.memmove
      64   2.1%  61.4%      112   3.7% reflect.valueInterface
      61   2.0%  63.4%      245   8.2% runtime.mapaccess2_faststr
      53   1.8%  65.2%     2141  71.3% github.com/Sereal/Sereal/Go/sereal.(*Encoder).encodeMap
      49   1.6%  66.8%       56   1.9% reflect.Value.Bytes
      48   1.6%  68.4%      482  16.1% reflect.Value.MapIndex
      41   1.4%  69.8%       41   1.4% reflect.Value.Kind
      41   1.4%  71.1%       41   1.4% runtime.gettype
      41   1.4%  72.5%       41   1.4% runtime.markscan
      36   1.2%  73.7%       58   1.9% github.com/Sereal/Sereal/Go/sereal.varint
      35   1.2%  74.9%     2145  71.4% github.com/Sereal/Sereal/Go/sereal.(*Encoder).encodeArray
      34   1.1%  76.0%       34   1.1% reflect.Value.Len
      32   1.1%  77.1%       32   1.1% reflect.Value.Index
      30   1.0%  78.1%       60   2.0% reflect.Value.Elem
      30   1.0%  79.1%       30   1.0% runtime.memclr
      29   1.0%  80.0%       29   1.0% reflect.(*rtype).NumMethod
      27   0.9%  80.9%      260   8.7% github.com/Sereal/Sereal/Go/sereal.(*Decoder).decode
```
]

--

.red[
80.9% - 1.2% - 1.8% - 4.9% = 73%
]

---
class: center, middle 

## WTF library is doing 3/4 of time???
![](wtf.jpg)

---
## Marshaller profile (before), continued

- memory operations: ~30%

- reflect: ~13%

- hash-related things: ~13%

- others: ~15%

--

- [profile graph](encoder-graphs-before.svg)

---
## Guilty function

.medium[
```go
func (e *Encoder) encodeMap(by []byte, m reflect.Value) []byte {
    keys := m.MapKeys()

    l := len(keys)
    by = append(by, typeHASH)
    by = varint(by, uint(l))

    for _, k := range keys {
        by, _ = e.encode(by, k)
        v := m.MapIndex(k)
        by, _ = e.encode(by, v)
    }

    return by
}
```
]

---
## Optimization concept

- Reflection is quite expensive and generates tons of garbage

--

- Let's get rid of reflection

--

- But I can't

--

- Okay, let's not use it as much as possible

--

- Resolution: .red[create set of shortcuts for common cases]

---
## Marshaller (after)

.medium[
```go
func (e *Encoder) encode(b []byte, v interface{}) ([]byte, error) {
    switch value := iface.(type) {

    case nil:
        b = append(b, typeUNDEF)
    case int:
        b = e.encodeInt(...)
    case float32:
        b = e.encodeFloat(...)
    case string:
        b = e.encodeString(...)
    case []uint8:
        b = e.encodeBytes(...)
    case []interface{}:
        b, err = e.encodeIntfArray(...)
    case map[string]interface{}:
        b, err = e.encodeStrMap(...)

    ...

    default:
        b, err = e.encodeViaReflection(b, reflect.ValueOf(value)) // i.e. old logic
    }
}
```
]

---
## Marshaller (after), continued

.medium[
```go
func (e *Encoder) encodeStrMap(by []byte, m map[string]interface{}) ([]byte, error) {
    by = append(by, typeHASH)
    by = varint(by, uint(len(m)))

    var err error
    for k, v := range m {
        by = e.encodeString(by, k, true, strTable)
        if by, err = e.encode(by, v); err != nil {
            return by, err
        }
    }

    return by, nil
}

func (e *Encoder) encodeMap(by []byte, m reflect.Value) []byte {
    keys := m.MapKeys()

    l := len(keys)
    by = append(by, typeHASH)
    by = varint(by, uint(l))

    for _, k := range keys {
        by, _ = e.encode(by, k)
        v := m.MapIndex(k)
        by, _ = e.encode(by, v)
    }

    return by
}
```
]

---
## Some magic ...

.medium[
```go
commit c562af4
Author: Ivan Kruglov <ivan.kruglov@booking.com>
Date:   2014-08-18 00:57:09 +0200

    Go decode: this tiny changes makes ????% of speed improvment

diff --git a/Go/sereal/decode.go b/Go/sereal/decode.go
index d0bf6c4..7972525 100644
--- a/Go/sereal/decode.go
+++ b/Go/sereal/decode.go
@@ -431,7 +431,6 @@ func (d *Decoder) decodeHash(by []byte, idx int, ln int, ptr *interface{}, isRef
                return 0, ErrCorrupt{errBadHashSize}
        }

*+       var key []byte
*+       var value interface{}
+
        for i := 0; i < ln; i++ {
*-               var key []byte
                key, idx, err = d.decodeStringish(by, idx)
                if err != nil {
                        return 0, err
                }

*-               var value interface{}
                idx, err = d.decode(by, idx, &value)
                if err != nil {
                        return 0, err

```
]

--

.center[.red[
    ~10% of speed improvement
]]

---
## ... which is not easily revealed by microbenchmarks

.medium[
```go
package benchmark_test

import (
    "testing"
    "strconv"
)

func BenchmarkDeclareInterfaceInside(b *testing.B) {
    hash := make(map[string]interface{}, b.N)

    for i := 0; i < b.N; i++ {
        var iface interface{}
        iface = i
        hash[strconv.Itoa(i)] = iface
    }
}

func BenchmarkDeclareInterfaceOutside(b *testing.B) {
    hash := make(map[string]interface{}, b.N)
    var iface interface{}

    for i := 0; i < b.N; i++ {
        iface = i
        hash[strconv.Itoa(i)] = iface
    }
}
```
]

.medium[
```terminal
$ go test -bench=.
testing: warning: no tests to run
PASS
BenchmarkDeclareInterfaceInside         10000000               290 ns/op
BenchmarkDeclareInterfaceOutside        10000000               285 ns/op
```
]

.small[
https://github.com/ikruglov/junk/blob/master/go-bench-loop-inf/benchmark_test.go
]

---
## Another trick

.medium[
```go
func BenchmarkConvertToStringOutside(b *testing.B) {
    var str string
    m := make(map[string]interface{})

    for i := 0; i < b.N; i++ {
        str = string(getValue(i)) // getValue() returns []byte of size 2K
        m[str] = i
    }
}

func BenchmarkConvertToStringInside(b *testing.B) {
    var slice []byte
    m := make(map[string]interface{})

    for i := 0; i < b.N; i++ {
        slice = getValue(i) // getValue() returns []byte of size 2K
        m[string(slice)] = i
    }
}
```
]

--

.medium[
```terminal
$ go test -bench=.
testing: warning: no tests to run
PASS
BenchmarkConvertToStringOutside   500000              3130 ns/op
BenchmarkConvertToStringInside    500000              2634 ns/op
```
]

.center[.red[
    again ~15% of speed improvement
]]

# 

.small[
    https://github.com/ikruglov/junk/blob/master/go-bench-hash-string/benchmark_test.go
]

---
## Hash access optimization

.medium[

]

.small[
    https://github.com/dgryski/trifles/tree/master/strtable
]

---
## Snappy/zlib pure Go vs pure C

---
## Conslusions

- Reflection is slow

- Try avoid using reflection

- Go is great!

---

---
## Some benchmarks

.medium[
```terminal
$ go test -bench=.

PASS
BenchmarkUgorjiMsgpackMarshal           200000              5366 ns/op
BenchmarkUgorjiMsgpackUnmarshal         500000              4784 ns/op
BenchmarkVmihailencoMsgpackMarshal      1000000             2460 ns/op
BenchmarkVmihailencoMsgpackUnmarshal    500000              3284 ns/op
BenchmarkJsonMarshal                    500000              4745 ns/op
BenchmarkJsonUnmarshal                  200000              8034 ns/op
BenchmarkBsonMarshal                    1000000             2915 ns/op
BenchmarkBsonUnmarshal                  500000              3655 ns/op
BenchmarkVitessBsonMarshal              1000000             1822 ns/op
BenchmarkVitessBsonUnmarshal            1000000             1051 ns/op
BenchmarkGobMarshal                     200000              9484 ns/op
BenchmarkGobUnmarshal                   50000               69573 ns/op
BenchmarkXdrMarshal                     500000              3618 ns/op
BenchmarkXdrUnmarshal                   1000000             2712 ns/op
BenchmarkUgorjiCodecMsgpackMarshal      500000              5184 ns/op
BenchmarkUgorjiCodecMsgpackUnmarshal    500000              5377 ns/op
BenchmarkUgorjiCodecBincMarshal         500000              6904 ns/op
BenchmarkUgorjiCodecBincUnmarshal       500000              6901 ns/op
*BenchmarkSerealMarshal                  500000              6502 ns/op
*BenchmarkSerealUnmarshal                500000              5386 ns/op
BenchmarkBinaryMarshal                  500000              3056 ns/op
BenchmarkBinaryUnmarshal                1000000             3006 ns/op
```

https://github.com/alecthomas/go_serialization_benchmarks
]

---
class: center, middle, inverse

# Thank you!
### https://github.com/Sereal/Sereal
### https://github.com/ikruglov

---

vim: ft=markdown
